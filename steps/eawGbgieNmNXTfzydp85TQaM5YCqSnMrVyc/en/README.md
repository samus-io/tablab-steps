# Git security best practices

* Git security refers to the measures and practices put in place to protect the integrity, confidentiality, and availability of data stored in Git repositories. This includes safeguarding against unauthorized access, data breaches, data loss, and other security threats.

## Enable and enforce 2FA on Git hosting platforms

* `Two-factor authentication (2FA)` adds an extra layer of security beyond just a username and password, making it significantly harder for attackers to gain unauthorized access to user accounts.
* Implementing two-factor authentication substantially improves the security of Git hosting platforms, reducing the possibility of attackers compromising the first authentication factor, which is usually username and password.

### Set up and workflow of 2FA

1. The process usually starts with the admin enforcing two-factor authentication for all users on the Git hosting platform.
1. During the configuration process, the user typically needs to choose a second authentication factor. This could be a `Time-Based One-Time Password (TOTP)` generated by an authenticator app, a text message (SMS) with a one-time code, or a hardware token.
1. When the user attempts to log in to their account, they provide their username and password as the first authentication factor, as usual.
1. After successfully providing the first factor, the user is prompted to provide the second factor for verification.
1. The user enters the second factor, which could be a code generated by an authenticator app, received via SMS, or provided by a hardware token.
1. Finally, the Git hosting platform verifies the second factor against the expected value associated with the user's account. If the second factor is correct, the user is granted access to their account.

## Limit access to repositories

* Limiting access to repositories in Git is essential for managing permissions efficiently, especially in larger organizations or projects with multiple contributors.
* Git hosting platforms such as GitHub, GitLab, and Bitbucket provide different access control levels that can be allocated to users or groups for each repository. These typically include:
  * **Owner/Administrator**: full control over the repository, including managing access permissions, merging pull requests, and managing repository settings.
  * **Write/Contributor**: can push changes to the repository, create branches, and open pull requests.
  * **Read/Viewer**: can clone and pull the repository, view code, issues, and pull requests, but cannot make changes.
  * **No Access**: cannot access the repository.
* Managing collaborators, who may be individuals or teams with access to a repository, ensuring that access is granted only to those who need it and regularly reviewing and updating the list of collaborators to remove access from users who no longer require it.

### Create user groups to limit access

* Instead of assigning permissions to individual users, groups can be created and permissions assigned to these groups. This approach simplifies management, particularly in large organizations with numerous users.
* Groups are typically formed based on roles, teams, or projects.
* Once groups are created, specific permissions can be assigned to them for repositories.
* For instance, a *Developers* group might be given write access to the code repositories, while a *Managers* group could be assigned read-only access for code review purposes.

## Rotate SSH tokens and personal keys

* Rotating SSH tokens and personal keys is a crucial security practice to mitigate the risk of unauthorized access and data breaches in Git repositories.
* This involves periodically changing the cryptographic keys used for authentication, which helps invalidate compromised or leaked keys and enhances overall security.

### Automate token and key rotation

* Manual rotation of SSH tokens and personal keys can be prone to human error and delays, potentially leaving repositories vulnerable to attacks. Automating this process simplifies and strengthens security by regularly generating new tokens or keys according to a predefined schedule or trigger events.
* Automated token and key rotation typically involves the following steps:
  1. **Scheduled rotation**: define a schedule for token and key rotation based on security best practices and organizational policies. This schedule could be monthly, quarterly, or as per industry standards.
  1. **Token/key generation**: implement a script or tool that generates new SSH tokens or personal keys automatically. These tokens/keys should be cryptographically secure and compliant with the required standards.
  1. **Revocation of old tokens/keys**: ensure that old tokens or keys are properly revoked and no longer usable for authentication. This step is crucial to prevent unauthorized access using outdated credentials.
  1. **Update configuration**: update the relevant configuration files or settings in the Git hosting platform to use the new tokens or keys for authentication. This ensures seamless transition without disruption to users' access.
  1. **Notification and monitoring**: implement notifications to alert administrators and users about upcoming token/key rotations, as well as successful completion of rotation tasks. Additionally, monitor access logs and security events to detect any unauthorized access attempts.

## Be cautious about including third-party apps to Git

* Before including any third-party app or code snippet in a Git repository, verify the source to ensure it comes from a trusted and reputable provider. Review the code for any suspicious or malicious content that could compromise the security of the repository.
* Keep track of the dependencies included in the project and regularly update them to the latest secure versions. Vulnerabilities in third-party dependencies can pose significant security risks, so staying up-to-date is essential.
* If a third-party app requires access to sensitive data or system resources, carefully evaluate whether it needs full access or if limited privileges can be granted instead.
* When adding GitHub apps to a CI/CD process, prioritize security. Read reviews, assess developers' reputation, and scrutinize access permissions. Ensure the app meets stringent security standards like SOC 2 or ISO/27001 compliance to safeguard the data effectively.

## Track activities via audit logs

* Tracking activities via audit logs in Git allows to monitor and record various actions performed within a repository or Git hosting platform. These audit logs provide valuable insights into user activities, changes made to code, and other important events, helping to maintain security, compliance, and accountability.
* Audit logs in Git:
  * Capture user actions such as commits, pushes, pulls, merges, and branch creations or deletions.
  * Include timestamps for each recorded action, indicating when the action occurred.
  * Detail changes made to files and directories within a repository, including additions, modifications, and deletions.
    * This visibility enables to track the evolution of code and identify who made specific changes.
  * Track user access to repositories, including cloning, forking, and viewing code.
  * Record security-related events such as authentication failures, access attempts from suspicious IP addresses, and changes to user permissions.
  * Facilitate compliance reporting by providing a detailed record of user activities and changes made to code.

### Sync an audit log service to a notification channel

* By following these generic steps, an audit log service can be efficiently synchronized with a notification channel, ensuring that all team remains aware of security alerts and user activities occurring in the repositories in real-time.
  1. **Choose an audit log service**: select an audit log service that integrates with the Git hosting platform and provides the necessary features for monitoring user activities and security events.
  1. **Configure audit log settings**: configure the audit log settings in the Git hosting platform to capture relevant security events and user activities. Enable logging for actions such as authentication failures, access attempts, changes to permissions, and repository activities.
  1. **Set up a notification channel**: choose a notification channel that the team regularly monitors, such as a Slack channel, email distribution list, or a collaboration platform. Ensure that all team members have access to the channel and can receive notifications in real-time.
  1. **Integrate audit log service with notification channel**: if the audit log service offers built-in integrations with the notification channel, follow the provided instructions to set up the integration. This may involve configuring webhooks, API integrations, or installing third-party connectors. If no built-in integration is available, explore methods such as using custom scripts or middleware to bridge the gap between the audit log service and the notification channel.
  1. **Test integration**: perform thorough testing to ensure that the integration between the audit log service and the notification channel is functioning correctly. Trigger test events in the Git hosting platform and verify that notifications are delivered promptly to the designated channel.
  1. **Monitor and aespond to alerts**: once the integration is set up, monitor the notification channel regularly for security alerts and user activity notifications from the audit log service. Promptly investigate any suspicious or unauthorized activities and take appropriate action to mitigate security risks.

## Backup the version control hosting environment

* Backing up the version control hosting environment is crucial for ensuring data integrity, disaster recovery, and business continuity.
* To accomplish this, it's important to:
  * Regularly schedule backups of all repositories, configuration settings, user permissions, and audit logs.
  * Utilize reliable backup solutions that support automation, encryption, and off-site storage to protect against data loss due to hardware failure, cyber attacks, or other unforeseen events.
  * Test backup restoration procedures periodically to verify their effectiveness and maintain documentation outlining backup policies and procedures.
* By implementing robust backup practices, organizations can safeguard their version control hosting environment and minimize the impact of potential disruptions.

## Use private repositories for sensitive data

* A Git hosting platform usually provides two types of repos in terms of accessibility:
  * **Public repo**: public repositories are accessible to anyone, allowing for open collaboration and contribution from the community. They are ideal for open-source projects, fostering transparency and knowledge sharing.
  * **Private repo**: private repositories restrict access to authorized users, ensuring confidentiality and control over sensitive code and data. They are suitable for proprietary projects, internal development efforts, or collaboration within restricted teams.
* Disable the creation of it if there is no need to use public repositories in the organization.

## Disable forking

* Disabling forking may be necessary for various reasons, such as protecting sensitive code, maintaining control over project versions, or enforcing compliance requirements.
* Here's why to disable forking in simple points:
  * Prevent unauthorized access to proprietary or confidential code by restricting the ability to create copies (forks) of repositories.
  * Maintain control over the official version of a project by preventing divergent branches or unauthorized modifications introduced through forks.
  * Ensure adherence to regulatory requirements or organizational policies by limiting access and distribution of code to authorized users only.
  * Minimize fragmentation and maintain a centralized codebase to streamline collaboration, code review, and project management processes.

## Ensure code branch protection

* Code branch protection is a security feature in version control systems like Git that allows repository administrators to enforce rules and restrictions on specific branches. These rules help maintain code quality, prevent accidental changes, and ensure that only authorized users can make modifications to protected branches.
* Git hosting platforms such as GitHub allows users to create branch protection rules in repositories for individual branches or for all branches.
* Here's how to ensure code branch protection:
  1. Access the settings page of the repository in the version control platform used (e.g., GitHub, GitLab).
  1. Look for the branch protection or branch settings section within the repository settings menu.
  1. Choose the branches that are protect, typically main branches like **main** as well as any other critical branches used for production releases or long-term development.
  1. Enable branch protection for the selected branches by toggling the appropriate settings or checkboxes.
  1. Define the specific rules and restrictions to enforce for protected branches. Common protection rules include:
      * Require pull request reviews before merging.
      * Require status checks to pass before merging (e.g., automated tests, code analysis).
      * Require a minimum number of approving reviews before merging.
      * Restrict who can push to the branch (e.g., specific users, teams, or administrators).
      * Require signed commits or commit message templates.
  1. Once branch protection rules are configured, save the changes to apply them to the repository.
  1. Test the branch protection settings by attempting to push changes directly to a protected branch or merge a pull request that doesn't meet the specified criteria. Monitor the repository's activity and review any notifications or alerts related to branch protection violations.

## Ensure commit signing

* Commit signing in Git is a process of digitally signing commits to ensure their authenticity and integrity.
* When author signs a commit, a cryptographic signature is attached to it using the GPG (GNU Privacy Guard) key. This signature verifies that the commit was made by author and has not been altered since it was signed.
* Ensuring commit signing in Git platforms offers several benefits in terms of:
  * **Data Integrity**: commit signing provides cryptographic verification that commits have not been tampered with, ensuring the integrity of the codebase.
  * **Authentication**: commit signing verifies the identity of the author, helping to prevent unauthorized or spoofed commits.
  * **Non-Repudiation**: signed commits cannot be denied by their author, providing a clear audit trail and accountability for code changes.
  * **Trustworthiness**: signed commits build trust among collaborators and contributors, especially in open-source projects or distributed teams.

## Regularly scan the repos

* Regularly scanning all Git repositories involves regularly checking the codebase for security vulnerabilities, code quality issues, and compliance violations. This helps ensure that the codebase remains secure, reliable, and compliant with relevant standards and regulations.

### Pre-commit hook scans

* Pre-commit hooks are scripts that run automatically before each commit is made to the repository.
* These hooks can be configured to execute various checks and scans on the code changes being committed.
* For example, pre-commit hooks can be set up to run static code analysis tools, security scanners, or linters to check for issues like syntax errors, code style violations, security vulnerabilities, and more.
* If any issues are detected during the pre-commit scan, the commit process is halted, and the developer is prompted to address the issues before proceeding with the commit.
* Pre-commit hook scans help catch issues early in the development process, preventing them from being introduced into the codebase.

### Scanning incoming pull requests

* Pull requests (PRs) are requests to merge code changes from one branch (usually a feature branch) into another (usually the main branch).
* Before merging a pull request, it's essential to ensure that the code changes are safe and meet the project's quality standards.
* Scanning incoming pull requests involves automatically running checks and scans on the code changes included in the PR.
* Similar to pre-commit hooks, these checks can include static code analysis, security scans, code reviews, and automated tests.
* If any issues are detected during the PR scan, they can be flagged to the PR author and reviewers for further review and resolution.
* Scanning incoming pull requests helps maintain the integrity of the codebase by preventing potentially harmful or low-quality changes from being merged.

## Automatically update dependencies

* Automatically updating dependencies refers to the practice of automatically keeping the software dependencies used in a project up to date with the latest versions available. Dependencies are external libraries, frameworks, or packages that a project relies on to function correctly.
* This is how it typically works:
  * Most modern programming languages have package managers or dependency management tools that help manage dependencies in a project. Examples include npm for Node.js.
  * Projects typically have a configuration file (e.g., package.json) where dependencies and their versions are listed. These files specify which versions of dependencies the project currently uses.
  * Automated tools or services can monitor these configuration files and check for updates to the listed dependencies. When updates are available, these tools automatically update the configuration files to use the latest compatible versions of the dependencies.
  * Automated dependency updates can be integrated into the project's CI pipeline. Whenever changes are made to the project's dependencies, the CI pipeline runs tests and builds the project to ensure that it still works correctly with the updated dependencies.
  * Automated tools may also provide notifications or alerts to project maintainers when updates are applied. This allows maintainers to review the changes and ensure they don't introduce any compatibility issues or breaking changes.
* Keeping dependencies up to date helps to protect the project from known vulnerabilities and security issues present in older versions of dependencies.
* Updates often include bug fixes and performance improvements that can enhance the stability and performance of the project.
* Reduces the burden on developers to manually track and update dependencies, freeing up time for other tasks.
* However, there are challenges like the updates may introduce breaking changes or compatibility issues with existing code or other dependencies and projects may need to lock dependencies to specific versions to maintain stability and prevent unexpected updates. For this reason, they should be implemented cautiously and accompanied by thorough testing and review processes.

## Prevent storing sensitive information

* Preventing the storage of sensitive information in Git repositories is crucial for maintaining security and compliance. Here are some best practices to achieve this:
  * **Avoid hardcoding sensitive info**: do not write passwords or keys directly into the code. Use environment variables or config files instead.
  * **Watch commit comments**: do not write sensitive details in commit messages. Keep comments generic to avoid revealing specifics.
  * **Use .gitignore**: create a `.gitignore` file to exclude sensitive files. This prevents Git from tracking them.
  * **Encrypt files if needed**: encrypt sensitive files before committing. Adds extra security in case files are accessed.

## Add a `SECURITY.md` file

* Include a `SECURITY.md` file alongside the `README.md` to centralize security information.
* The `SECURITY.md` file serves as a cornerstone for fostering a secure and collaborative project environment. It promotes responsible security practices, informs users about vulnerabilities, and encourages active participation in improving project security for a resilient ecosystem.
* The `SECURITY.md` file typically contains essential security-related information and guidelines for a project.

### Introduction

* Add a brief introduction explaining the purpose of the `SECURITY.md` file and its importance in promoting responsible security practices within the project.

### Disclosure policy

* Add clear instructions on how individuals should report security vulnerabilities, including contact information (e.g., email address) for responsible disclosure.
* Here, clearly outline what types of security issues are within the scope of the disclosure policy.
* Instructions are required to be provided for how individuals should report security vulnerabilities. Designate a contact point for responsible disclosure. Encourage reporters to refrain from publicly disclosing vulnerabilities until they have been adequately addressed.
* This encourages collaboration in managing vulnerabilities.

### Security update policy

* Add details on how the project plans to disseminate information about newly identified security vulnerabilities, including notification channels and steps for users to address issues promptly.
* Define how the project will inform users about new security vulnerabilities.
* Also, specify notification channels and steps for users to address issues promptly.

### Security-related configuration

* Add guidance on configuring security settings for project deployments, including recommended best practices and considerations for enhancing deployment security.
* Provide guidance on configuring security settings for project deployments.
* And, help users make informed choices to enhance deployment security.

### Known gaps and future enhancements

* Add transparent communication about existing security gaps that are recognized but not yet addressed, as well as insights into future security enhancements under consideration.
* Existing security gaps, yet to be addressed, needs to be transparently communicated.
* Share plans for future security improvements and encourage collaboration from contributors to enhance projects.
